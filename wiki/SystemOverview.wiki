#summary The components of the Teyjus system

=  An Overview of the Teyjus System =

The approach to implementing _Lambda Prolog_ that has been developed in the _Teyjus_ project is the following. First, we have designed an abstract or virtual machine that has an instruction set and supporting structures that can be used to realize all the high-level computations implicit in a _Lambda Prolog_ program. Then we have developed techniques for translating or compiling actual _Lambda Prolog_ programs to instructions that can run on this virtual machine. 

It is, of course, legitimate to wonder at this point what the benefit is of executing _Lambda Prolog_ programs that are compiled in this way instead of directly interpreting the programs. In fact, several arguments can be extended in support of this approach. First, while the construction of this virtual machine has paid close attention to what is needed for _Lambda Prolog_, it also has been designed keeping in mind what is practical to realize in hardware. Thus, it is conceivable that it may be realized in silicon, thereby obviating an interpretation step. More realistically, though, the abstract machine will be emulated in software. Even then, there are benefits. For example, the process of examining and translating a program allows us to notice certain computations that can already be done at compile-time, thereby improving dynamic behaviour in the translated version of the program. As another example, translating initially to a congenial target such as the virtual machine instructions allows us to understand the nuances better so that a more difficult subsequent goal of directly generating native code becomes manageable. Finally, the virtual machine can itself have a purpose: it can be treated as an intermediate language to which other similar high-level languages can be translated. Within the _Teyjus_ project, we are actually exploring the possibility of providing such an implementation of the [http://twelf.plparty.org/wiki/Main_Page Twelf] specification language using this approach.


The _Teyjus_ implementation of _Lambda Prolog_ actually uses an emulator for the virtual machine. Thus, there are two main components to the systems: a compiler and an emulator. The function of the compiler is to process any given module of Lambda Prolog code, to certify its internal consistency and to ensure that it satisfies a promise determined by an associated signature and, finally, to translate it into a byte-code form consisting of a "header" part consisting of constant and type names and other related data structures and sequences of instructions that can be run on the abstract machine that has understood the header information. A critical part of the emulator is a "loader" that can read in such byte-code files and put the emulator in a state where it is ready to respond to user queries. The other part of the emulator is, of course, a byte-code interpreter that steps through instructions in the manner called for by the user input. 

The _Lambda Prolog_ language contains also modularity features that allow large systems to be constructed by composing smaller modules. The _Teyjus_ system supports separate compilation relative to this language. What this means is that the compiler must process each module separately from any other and must generate code in such a way that it can be combined with the compiled forms of other relevant modules to build the eventual image that is desired to be run. This extra "composition" information that is generated by the compiler is actually another part of the header information in byte-code files. The task of composing these files is taken up by a third component of the _Teyjus_ system, the linker. 

There are two other utilities that complete the suite of executables available after you build the _Teyjus_ system. One of these is a disassembler that can be used to display byte-code files---whether linked or unlinked---in a readable form. Of course, you need to know something about the instruction set (at least the one that underlies Prolog or a related language) to make sense of what you get from disassembling. The second utility is a dependency analyzer. This program can look at a module and calculate all the signatures that are needed to understand its code and all the other modules that are needed to produce a completely linked, executable image of the given one. This dependency analyzer can be extremely helpful in constructing a Makefile that exploits the separate compilation feature of _Teyjus_.

The names of the different executables: the compiler is called _tjcc_, the emulator is called _tjsim_, the linker is called _tjlink_, the disassembler is called _tjdis_ and the dependency analyzer is called _tjdepend_. The compiler produces byte-code files that have the extension _.lpo_ and the linker combines such files to produce an final loadable and executable image with the extension _.lp_. 

Finally a few words about the languages used in the implementation of the system. The underlying idea was to use the functional language _OCaml_ wherever this was possible without compromising efficiency and to use _C_ when proximity to the underlying machine was of concern. This naturally led to the compiler and dependency analyzer being written in _OCaml_ and the emulator (with its loader component) in _C_. The front end of the emulator that includes a query processor has been written also in OCaml, so that there is need for OCaml code to call a _C_ function. There are certain builtins within the emulator that utilize parser functions so, in this case, there is a communication in the reverse direction between _C_ code and _OCaml_ code. The linker is currently written in _C_ but could well have been developed in _OCaml_; this conversion may well be undertaken at a later point in the life of the project in support of readability and modifiability. Similarly, there are certain "build" functions that ensure, for example, shared information between the compiler and the emulator that are currently written in _C_ but may be converted into _OCaml_ code in the future.