#summary Syntax of Modules

= The Structure of Source Code for a Module =

We describe here the structure of declarations constituting the source code for a module that is contained in a file called <modname>.mod. As already explained, this source code file goes hand-in-hand with the signature file for the module and requires the latter to be used in its interpretation.

The Teyjus parser for the source code file consists of a part automatically generated by the _OCaml_ parser generator from a context-free grammar and a post processor that manipulates the (pre) abstract syntax structures generated by the automatically constructed parser. The post processing phase is needed to handle information such as arities of type constructors and operator fixities and precedence that is also gleaned through the parse. The grammar below represents the effect of the combined processing and should not be confused with the one that forms the input to the parser generator.

== A BNF Specification of Module Syntax ==

The rules below describe the syntax of the declarations that may appear in a module file. These grammar rules build on the ones already presented while explaining the syntax of signatures in [SigSyntax A BNF Specification of Signature Syntax]. Thus, to understand this grammar, it may be necessary to consult also the grammar for signatures.
 	
{{{
<Module>        ::=  <ModHeader> <ModPreamble> <ModBody> <ModEnd>

<ModHeader>     ::=  'module' <NameToken> '.'

<ModEnd>        ::=  '$'                        % $ stands for eof
                   | 'end' 

<ModPreamble>   ::=  <Empty>
                   | 'import' <NameTokens> '.' <ModPreamble>
                   | 'accumulate' <NameTokens> '.' <ModPreamble>
                   | 'accum_sig' <NameTokens> '.' <ModPreamble>
                   | 'use_sig' <NameTokens> '.' <ModPreamble>

<ModBody>       ::=  <Empty> 
                   | <ModSignDecl> <ModBody>
                   | <ModClause> <ModBody>

<ModSignDecl>   ::=  <Sign-Decl>
                   | 'local' <Ids> '.'
                   | 'local' <Ids> <Type> '.'
                   | 'localkind' <Ids> '.'
                   | 'localkind' <Ids> <Kind> '.'

<ModClause>     ::=  <Clause> '.'

<Clause>        ::=  <Atom>
                   | <Clause> ':-' <Goal>
                   | <Goal> '=>' <Clause>
                   | <Clause> ',' <Clause>
                   | <Clause> '&' <Clause>
                   | <PiId> <TypedId> '\' <Clause>
                   | <PiId> <CTerm>
                   | '(' <Clause> ')'

<Goal>          ::=  '!'
                   | <PiId> <Term>
                   | <PiId> <TypedId> '\' <Goal>
                   | <SigmaId> <Term>
                   | <SigmaId> <TypedId> '\' <Goal>
                   | <Goal> ';' <Goal>
                   | <Goal> ',' <Goal>
                   | <Goal> '&' <Goal>
                   | <Clause> '=>' <Goal>
                   | <Atom>
                   | <FlexAtom>
                   | '(' <Goal> ')'


<Atom>          ::=  <Term>    { the type of the term must be boolean
                                 and its main functor must be a constant
                                 or a variable bound by an enclosing
                                 essential universal quantifier }

<FlexAtom>      ::=  <TypedVar>
                   | <FlexAtom> <AppTerm>
                   | '(' <FlexAtom> ')'


<CTerm>         ::=  <Term>    { The main functor of the term must be a 
                                 constant or a variable bound by an
                                 enclosing essential universal 
                                 quantifier }

<Term>          ::=  <Term> <TypedCIdent> <Term>   
                   | <Term> <TypedCIdent>          
                   | <TypedCIdent> <Term>          
                   | <Term> <Term>
                   | <TypedId> '\' <Term>
                   | '[' ']'                    % Prolog list notation
                   | '[' TermList ']'           % Prolog list notation
                   | '[' TermList '|' Term ']'  % Prolog list notation
                   | <TypedCIdent>
                   | <TypedVar> 
                   | <TypedId>
                   | '(' <Term> ')'

<TermList>      ::=  <Term>
                   | <Term> ',' <TermList>

<PiId>          ::=  'pi'
                   | 'pi' ':' <Type>
                   | '(' <PiId> ')'

<SigmaId>       ::=  'sigma'
                   | 'sigma' ':' <Type>
                   | '(' <SigmaId> ')'

<TypedId>       ::=  <AbsToken>
                   | <AbsToken> ':' <Type>
                   | '(' <TypedId> ')'

<TypedVar>      ::=  <VIdent>
                   | <VIdent> ':' <Type>
                   | '(' <TypedVar> ')'

<TypedCIdent>   ::=  <SpecialOp>
                   | <Id>
                   | <Id> ':' <Type>
                   | '(' <TypedCIdent> ')'

<SpecialOp>     ::=  { A pseudo keyword corresponding to one of the 
                        overloaded operators }

<AbsToken>      ::=  { A <NameToken> that does not begin with _ }

<VIdent>        ::=  { A Teyjus token that begins with an uppercase
                        letter or _ and that is not the variable bound
                        by an enclosing abstraction }
}}}

== Commentary on Module Syntax ==

The module declaration must satisfy certain properties in addition to adhering to the syntax rules:

    * Each module is expected to be presented in a distinct file. This file must have the name _<modname>.mod_ where _<modname>_ is the name of the relevant module and the associated signature. This name should also coincide with the name indicated in the module header, generated by the rule for _<ModHeader>_.

    * Accumulate, import, accumsig and usesig declarations are those appearing in the module preamble (i.e. generated by the rule for _<ModPreamble>_) and beginning with the tokens _accumulate_, _import_, _accum`_`sig_ and _use`_`sig_ respectively. The accumsig and usesig declarations have a role in module declarations that is similar to the one they have in signature declarations. Accumulates and imports have been explained informally in the section the [ProgramStructure structure of programs] in _Teyjus_. This informal description is further bolstered by the presentation elsewhere of the rules for [SigMatching matching signatures with modules] and for [SigAnnotation certifying module interactions].

    * Local constant and local kind declarations are those in the category _<ModSignDecl>_ that begin with the tokens local and localkind respectively. These declarations identify constants and kinds whose scope is limited to the module in which they appear and to the code obtained from the modules imported and accumulated by that module. 

    * Closed constant declarations are those in the category _<ModSignDecl>_ that begin with the token _closed_. Every closed constant must be of predicate type. From an outward perspective, these constants behave like _exportdef_ constants: their definitions are exported from the module in question and these cannot be changed in the importing or accumulating context. From an inward perspective, these constants are ones for which an assurance can be given of fixity of code. Thus, they should either be defined as _useonly_ or they should not be globals in imported modules reachable through some chain of accumulates.

    * There is some redundancy in module syntax. In particular, _exportdef_, _useonly_, _local_ and _localkind_ declarations may be left out; the former two must also appear in the explicit signature file and locals can be taken to be the complement of the sorts, type constructors and constants defined in the explicit signature file. However, they are included in the syntax of modules to permit a preprocessing phase that calculates the explicit signature. This is not the preferred situation though and is not one used in the _Teyjus_ system; signature files are intended to be useful in the certification of module interactions and are not an obstacle to be surmounted in whichever way possible and, for this reason, are required to be explicitly provided for every module in the _Teyjus_ framework.

    * The name of a predicate defined by a clause that appears at the top level in the module or in the antecedent of an implication goal must not be identical to that of a logical symbol or a _useonly_ predicate. It must not also be identical to that of a built-in predicate unless the predicate name has been redefined through a type declaration.

    * There must be at most one arity and type associated with any given _Id_. There might be multiple declarations for this _Id_ but all must agree eventually.

    * In the form
{{{
             <Term> <TypedCIdent> <Term> 
}}}

      that appears in the rules for _<Term>_, the identifier must have been declared as an infix operator. Similarly, in the form     	
{{{
             <Term> <TypedCIdent>
}}}

      that appears in the rule for _<Term>_, the identifier must have been declared as a postfix operator and in the form    	
{{{
             <TypedCIdent> <Term>
}}}

      the identifier should have been declared as a prefix operator. The rule for _<Term>_ is obviously ambiguous as written. Disambiguation is to be affected using the precedence and associativity of the relevant operators. In this context, it is also to be noted that abstraction and application are treated like (infix) operators, that application is left associative and has higher precedence than all other operators and abstraction is right associative and has lower precedence than all other operators.

    * The comma (',') token is overloaded: it can be read as the symbol for conjunction or as the separator between list elements in the _Prolog_ style list notation that is supported within the _Teyjus_ system. The rule for disambiguating this operator is simple. It is read as a list separator when it appears at the top-level in a list context and is read as the conjunction operator everywhere else. To illustrate these conventions, suppose that _p_, _q_ and _r_ are constants of propositional (or, more precisely, _o_) type. Then the expression 
{{{
           [ p,q,s]
}}}

      is read as a list of three elements each of propositional type, whereas 
{{{
           [(p, q, r)]
}}}

      is a list that has exactly one element that is the conjunction of _p_, _q_ and _r_. Note that lists have an alternative, _ML_-like, syntax that is based on using the constants _::_ and _nil_.

    * The arithmetic operators like +, `*` and - and the comparison operators <, =<, > and >= are also overloaded. For these operators, the disambiguation rule is as follows: if the type of the operator can be determined from that of either of its arguments, then it is assumed to have that type, else it is assumed to take integer arguments.

    * There are the usual typing restrictions on well-formedness.

    * The constants representing implication are not permitted to appear embedded inside terms.

    * Signature files should exist for all accumulated and imported modules and accumulated and used signatures at the time of parsing and type-checking a module.

    * We can calculate a signature from the source code for a module by taking the type, kind and fixity declarations in a module, adding to these the accumulated signatures and signatures of accumulated and imported modules and removing all the declarations corresponding to local constants and localkind types. The type association for all the constants and the arity association for all the kinds in this signature that are also defined in the signature file for the module must be identical. All the objects in this calculated signature that do not also appear in the explicitly defined signature are interpreted as local or localkind objects.

    * All _exportdef_ and _useonly_ declarations in the calculated signature must be for global constants and must also appear in the explicit signature. All fixity declarations for global constants in the calculated signature must also appear in the explicit signature. A global constant that is defined to be closed (in the module source) should be _exportdef_ in the explicit signature.

    * Tokens that begin with uppercase letters are to be interpreted as variables. Such variables may be bound or free depending on whether or not they are captured by an enclosing abstraction. Notice in contrast that tokens that begin with `_` can only be free variables. Notice also that bound variables may, in addition, begin with lower case letters or sign characters, much like constant tokens. Free variables that appear in clauses are to be understood as being implicitly universally qualified at the head of the clause. All occurrences of a (bound or free) variable in a clause must have the same type.

    * In the rule for an _<Atom>_, the head is permitted to be an essentially universally quantified variable. In determining the interpretation of a quantifier, the assumption is that a top-level clause in a module appears in a negative context.

    * Every sort and type constructor that is used in the type declarations and clauses in a module must be explicitly declared. Similarly, every constant that is used in the clauses that define predicates in a module must be explicitly declared. Queries in the _Teyjus_ system are posed relative to modules. All constants, sorts and type constructors that are used in such queries must be defined in the signature corresponding to the module. 

    * A chain of imports or accumulates from a given module must not lead back to the same module. A violation of this "syntactic" property cannot be detected at compile time without violating the philosophy of separate compilation. However it can be and is checked at linking time. 